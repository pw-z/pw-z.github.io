# 独立开发原型应用涉及的基础技术栈回顾

*Posted on 2024.06.03 by [pwz](http://pwz.wiki) under [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)* 

目前为止设计实现一个原型应用的基本环节：

1. 需求确认
2. 模型设计、数据库设计
3. 后端服务实现
4. 前端服务实现

此外还需要持续集成等技术支撑如上流程的高效运转。

- [独立开发原型应用涉及的基础技术栈回顾](#独立开发原型应用涉及的基础技术栈回顾)
  - [后端](#后端)
    - [Java语言基础](#java语言基础)
    - [Spring开发框架](#spring开发框架)
    - [Java单体应用项目结构](#java单体应用项目结构)
    - [MySQL数据库](#mysql数据库)
    - [MyBatis持久层框架](#mybatis持久层框架)
    - [Maven项目管理和构建工具](#maven项目管理和构建工具)
  - [前端](#前端)
    - [HTML、CSS与JS基础](#htmlcss与js基础)
    - [React框架](#react框架)
    - [Next.js开发框架](#nextjs开发框架)
    - [Axios网络请求](#axios网络请求)
  - [通过Github Action持续集成](#通过github-action持续集成)


## 后端

### Java语言基础

> Prompt for 文心一言3.5: 帮我总结一下Java这门语言的基础知识点大纲，注意是大纲而不是细节

好的，以下是一个简化的Java语言基础知识点大纲，涵盖了Java编程的核心概念：

**一、Java概述**

1. Java语言的历史和特点
2. Java平台：JRE, JDK, JVM
3. Java的主要应用领域

**二、Java基础语法**

1. 关键字、标识符、数据类型
   - 基本数据类型（整型、浮点型、字符型、布尔型）
   - 引用数据类型（类、接口、数组）
2. 变量和常量
3. 运算符和表达式
4. 控制流语句（条件语句、循环语句、跳转语句）

**三、面向对象编程**

1. 类和对象
   - 类的定义
   - 对象的创建和使用
   - 构造方法
   - 访问修饰符（public, private, protected, 默认）
2. 继承
   - 继承的概念和语法
   - 方法的重写（Override）
   - super关键字
3. 多态
   - 方法重载（Overloading）
   - 向上转型和向下转型
   - instanceof操作符
4. 抽象类和接口
   - 抽象类
   - 接口的定义和实现
   - 接口的多重实现
5. 封装、继承、多态的意义

**四、异常处理**

1. 异常的概念和分类
2. try-catch-finally语句块
3. 自定义异常
4. 异常链和异常的传播

**五、Java常用类库**

1. String类
   - 字符串的创建和比较
   - 字符串常用方法
2. 包装类
   - 基本数据类型与包装类的转换
   - 包装类的常用方法
3. 集合框架
   - List, Set, Map接口及其实现类
   - 迭代器（Iterator）
   - 泛型（Generics）
4. 日期和时间API
   - LocalDateTime, LocalDate, LocalTime等

**六、输入/输出（I/O）**

1. File类
2. 字节流（InputStream, OutputStream）
3. 字符流（Reader, Writer）
4. 缓冲流（BufferedInputStream, BufferedOutputStream等）
5. 文件流（FileInputStream, FileOutputStream等）
6. 对象序列化

**七、多线程编程**

1. 线程的基本概念
2. 线程的创建（继承Thread类，实现Runnable接口）
3. 线程的状态和生命周期
4. 线程同步和互斥（synchronized关键字，Lock接口）
5. 线程间的通信（wait/notify/notifyAll）
6. 线程池

**八、网络编程**

1. 网络基础知识（TCP/IP, HTTP等）
2. Socket编程
   - ServerSocket和Socket类
   - TCP编程示例
3. URL和URLConnection
4. Java NIO（非阻塞I/O）

**九、泛型、注解和反射**

1. 泛型（Generics）
2. 注解（Annotations）
3. 反射（Reflection）

**十、Java 8及之后的新特性**

1. Lambda表达式和函数式接口
2. Stream API
3. Optional类
4. 接口中的默认方法和静态方法
5. 局部变量类型推断（var）
6. 其他新特性和增强（如模块化、日期和时间API的增强等）

这个大纲涵盖了Java语言的基础知识点，但请注意，每个部分都包含了许多细节和深入的内容，需要进一步的学习和实践来掌握。


### Spring开发框架

> Prompt for Kimi: Spring框架帮我们做了什么事情？

Spring框架是一个开源的Java平台，它为企业级应用程序提供了全面的基础架构支持。Spring帮助开发者在多个方面简化了应用程序的开发和管理，以下是Spring框架主要帮助我们做的事情：

1. **依赖注入（DI）**：Spring通过依赖注入机制管理对象的创建和依赖关系，减少了代码间的耦合度，提高了代码的模块化。

2. **面向切面编程（AOP）**：Spring AOP提供了一种方法，允许开发者将横切关注点（如日志记录、事务管理等）与业务逻辑分离，从而提高代码的可维护性和可重用性。

3. **数据访问和集成**：Spring提供了对各种数据访问技术的统一接口，包括JDBC、Hibernate、JPA等，简化了数据持久层的开发。

4. **事务管理**：Spring提供了一个事务管理的抽象层，可以轻松地进行声明式和编程式事务管理，支持多种事务管理器。

5. **模型-视图-控制器（MVC）**：Spring MVC是一个用于构建Web应用程序的MVC框架，它简化了模型、视图和控制器的分离，使得Web应用程序的分层更加清晰。

6. **安全性**：Spring Security提供了一个全面的安全服务，支持认证和授权，帮助保护应用程序的安全。

7. **测试**：Spring提供了对各种测试策略的支持，包括单元测试、集成测试和Web测试，简化了测试过程。

8. **模块化**：Spring框架是高度模块化的，开发者可以根据需要选择使用哪些模块，这有助于保持应用程序的轻量级。

9. **RESTful Web服务**：Spring可以帮助开发者构建RESTful Web服务，简化了Web服务的开发和维护。

10. **消息传递**：Spring提供了对消息传递的支持，包括JMS和AMQP等，使得应用程序可以轻松集成消息队列和消息代理。

11. **调度**：Spring提供了任务调度功能，简化了定时任务的创建和管理。

12. **配置管理**：Spring允许使用XML、注解或Java配置类来管理配置，提供了灵活的配置选项。

13. **国际化**：Spring支持国际化，使得应用程序可以轻松地适应不同地区的用户。

14. **Spring Boot**：作为Spring的一个子项目，Spring Boot进一步简化了Spring应用程序的初始搭建和开发过程。

15. **微服务支持**：Spring Cloud提供了对微服务架构模式的支持，帮助开发者构建分布式系统。

总的来说，Spring框架通过提供一套丰富的企业级服务和简化的编程模型，极大地提高了Java企业级应用程序的开发效率，降低了维护成本，并帮助开发者关注于业务逻辑的实现。



> Prompt for 文心一言3.5: 能对比一下有Spring以及Spring Boot框架和没有他们的情况下，完成一个Web项目的主要区别么

在对比使用Spring、Spring Boot框架与不使用它们完成Web项目的主要区别时，我们可以从以下几个方面进行详细的分析和归纳：

**一、项目搭建和配置**

1. **不使用框架**：
   - 需要手动配置Web服务器（如Tomcat、Jetty等）。
   - 需要编写大量的配置代码，如Servlet的映射、过滤器、监听器等。
   - 配置过程繁琐，容易出错，且不易于维护。

2. **使用Spring框架**：
   - 提供了IoC（控制反转）和AOP（面向切面编程）的功能，有助于解耦和简化开发。
   - 提供了丰富的Web开发支持，如Spring MVC，可以简化Web层的开发。
   - 但仍然需要手动配置很多组件，如数据源、事务管理器等。

3. **使用Spring Boot框架**：
   - 基于Spring框架构建，继承了Spring的所有优点。
   - 提供了自动配置的功能，通过添加依赖和注解，可以自动配置常用的组件，如数据源、事务管理器等。
   - 大大简化了项目的搭建和配置过程，开发者可以更加专注于业务代码的实现。
   - 提供了多种默认配置，可以快速构建独立的、可执行的JAR包，使得应用的部署变得更加简单。

**二、开发效率**

1. **不使用框架**：
   - 需要手动编写大量的配置代码和业务代码，开发效率较低。
   - 难以快速构建和测试应用。

2. **使用Spring框架**：
   - 通过IoC和AOP等特性，可以提高代码的可重用性和可维护性，从而提高开发效率。
   - 提供了丰富的Web开发支持，可以简化Web层的开发。

3. **使用Spring Boot框架**：
   - 提供了快速开发的特性，如内嵌的HTTP容器、自动配置等，可以进一步提高开发效率。
   - 支持快速构建和测试应用，通过Maven或Gradle等构建工具，可以快速生成可执行的JAR包或WAR包。

**三、可维护性和扩展性**

1. **不使用框架**：
   - 项目结构可能较为混乱，代码可维护性和扩展性较差。

2. **使用Spring框架**：
   - 通过IoC和AOP等特性，可以实现松耦合的应用，使得代码更易于测试、维护和扩展。
   - 提供了丰富的扩展点，可以方便地集成各种优秀的框架和库。

3. **使用Spring Boot框架**：
   - 继承了Spring框架的所有优点，同时提供了更加简洁和快速的配置方式，使得项目的可维护性和扩展性得到了进一步的提升。

**四、部署和监控**

1. **不使用框架**：
   - 需要手动部署应用到Web服务器中，过程繁琐且容易出错。
   - 监控和诊断应用问题较为困难。

2. **使用Spring框架**：
   - 虽然简化了Web层的开发，但在部署和监控方面并没有提供太多的支持。

3. **使用Spring Boot框架**：
   - 支持一键启动和快速部署，可以通过java -jar命令直接运行JAR包。
   - 提供了基于spring-boot-actuator组件的监控功能，可以通过RESTful接口获取JVM性能指标、线程工作状态等运行信息，方便进行应用的监控和诊断。

综上所述，使用Spring和Spring Boot框架可以显著提高Web项目的开发效率、可维护性和扩展性，并简化项目的搭建和配置过程。其中，Spring Boot通过自动配置和快速开发的特性，进一步简化了Spring应用的开发过程，使得开发者可以更加专注于业务代码的实现。


### Java单体应用项目结构

> Prompt for 文心一言3.5 and Kimi： Java单体应用项目结构一般如何规划，有哪些经典的架构思想？

Java单体应用项目结构的规划通常基于一系列经典的架构思想和最佳实践。以下是一个清晰的规划方案，结合了参考文章中的相关数字和信息：

一、项目结构规划

1. **模块化设计**
   - **目的**：将项目划分为多个模块，每个模块负责不同的功能，以实现高内聚、低耦合。
   - **实现**：使用Maven或Gradle等构建工具，通过定义多个子模块来划分项目。

2. **分层架构**
   - **经典三层架构**：
     1. **表示层（Presentation Layer）**：负责与用户交互，展示数据和接收用户输入。通常使用JSP、Thymeleaf等模板引擎或Spring MVC等框架。
     2. **业务逻辑层（Service Layer）**：处理核心业务逻辑，包括数据验证、业务规则等。通常使用Spring的Service组件实现。
     3. **数据访问层（Data Access Layer）**：负责与数据库交互，执行CRUD操作。通常使用MyBatis、Hibernate等ORM框架或Spring Data JPA。

3. **目录结构**
   - **src/main/java**：存放Java源代码。
     - **com.example.project.controller**：存放表示层代码，即Controller类。
     - **com.example.project.service**：存放业务逻辑层代码，即Service类。
     - **com.example.project.repository**：存放数据访问层代码，即Repository或DAO类。
     - **com.example.project.config**：存放配置相关代码，如Spring Boot的配置类。
   - **src/main/resources**：存放资源文件，如配置文件（application.properties或application.yml）、模板文件、静态资源等。

Java单体应用项目结构的规划和架构思想是软件开发中的重要部分，它可以帮助开发者构建可维护、可扩展和可测试的应用程序。以下是一些常见的单体应用项目结构规划方法和经典架构思想：


二、经典架构思想

1. **MVC（Model-View-Controller）**：
   - 将应用程序分为模型（数据）、视图（用户界面）和控制器（业务逻辑）三个部分，以提高代码的可维护性和可扩展性。

2. **DRY（Don't Repeat Yourself）**：
   - 避免代码重复，提高代码的可重用性。

3. **SOLID原则**：
   - 五个面向对象设计的基本原则，帮助开发者设计出高质量的软件系统。

4. **微服务架构**（虽然不是单体应用，但了解微服务的概念有助于理解单体架构的局限性）：
   - 将应用程序拆分成一系列小的服务，每个服务运行在其独立的进程中，并通过轻量级的通信机制进行交互。

5. **六边形架构**（也称为端口与适配器架构）：
   - 将应用程序的核心逻辑与外部通信机制解耦，使得应用程序更容易测试和维护。

6. **DDD（领域驱动设计）**：
   - 通过将业务逻辑集中在领域模型上，提高软件的质量和可维护性。

7. **CQRS（Command Query Responsibility Segregation）**：
   - 将命令（写操作）和查询（读操作）的责任分离，以提高性能和可扩展性。

8. **事件驱动架构**：
   - 应用程序通过事件来驱动业务逻辑的执行，提高系统的响应性和可扩展性。

在规划Java单体应用项目结构时，开发者需要根据项目的具体需求和团队的偏好来选择合适的架构思想和项目结构。同时，随着项目的发展，可能需要对架构进行调整以适应新的需求。


### MySQL数据库

> Prompt for Kimi: 总结一下在常规项目中使用MySQL数据库需要掌握的核心知识点大纲

在常规项目中使用MySQL数据库，需要掌握一系列核心知识点，以确保数据库的高效、安全和可维护性。以下是一份核心知识点大纲：

1. **MySQL基础**
   - MySQL的安装、配置和启动。
   - MySQL的架构和组件。

2. **数据库设计**
   - 理解关系型数据库的设计原则。
   - 数据库规范化（1NF, 2NF, 3NF）。
   - 创建数据库和表。
   - 设计索引以优化查询性能。

3. **SQL语言**
   - 编写复杂的SQL查询，包括连接（JOIN）、子查询和集合操作。
   - 使用事务处理来保证数据的一致性。
   - 掌握SQL模式（Schema）的使用和管理。

4. **数据类型和约束**
   - 熟悉MySQL支持的各种数据类型。
   - 应用约束（如主键、外键、唯一、非空等）来保证数据完整性。

5. **数据操作**
   - 插入（INSERT）、更新（UPDATE）、删除（DELETE）和查询（SELECT）数据。
   - 批量数据处理。

6. **高级查询**
   - 使用GROUP BY和HAVING进行数据分组和筛选。
   - 使用窗口函数（如ROW_NUMBER, RANK等）。

7. **存储过程和函数**
   - 创建和使用存储过程（Stored Procedures）。
   - 创建和使用函数（Functions）。
   - 管理触发器（Triggers）。

8. **视图**
   - 创建和使用视图（Views）简化复杂查询。

9. **性能优化**
   - 索引优化和查询优化。
   - 使用EXPLAIN分析查询性能。
   - 性能监控和调优。

10. **安全性**
    - 用户账号和权限管理。
    - 数据加密和安全传输。
    - SQL注入防护。

11. **备份与恢复**
    - 定期备份策略。
    - 数据库恢复流程。

12. **复制**
    - 理解主从复制（Master-Slave Replication）。
    - 读写分离。

13. **高可用性和故障转移**
    - 了解高可用性解决方案，如MySQL Cluster或Galera Cluster。
    - 故障转移机制。

14. **监控与维护**
    - 使用监控工具（如MySQL Workbench, Percona Monitoring and Management）。
    - 日志管理（错误日志、查询日志等）。
    - 定期维护任务，如优化表（OPTIMIZE TABLE）。

15. **版本控制和升级**
    - 了解MySQL版本差异。
    - 数据库升级策略和步骤。

16. **分布式数据库概念**
    - 了解分布式数据库的基本概念和挑战。

17. **云数据库服务**
    - 了解如何在云平台（如AWS RDS, Google Cloud SQL）上部署和管理MySQL。

这份大纲涵盖了在常规项目中使用MySQL数据库时需要掌握的核心知识点。根据项目的具体需求，某些知识点可能需要更深入的学习和实践。


### MyBatis持久层框架

> Prompt for 文心一言3.5: 你知道MyBatis持久层框架吗

MyBatis持久层框架是一个优秀的开源框架，用于实现数据持久化。以下是关于MyBatis的详细介绍：

一、概述

MyBatis是一个支持定制化SQL、存储过程和高级映射的持久层框架。它避免了几乎所有的JDBC代码和手动设置参数以及获取结果集的繁琐过程，使开发者能够更专注于SQL本身，而无需关心JDBC的底层实现细节。

二、特点

1. **简单易学**：MyBatis没有任何第三方依赖，易于学习和使用。
2. **灵活**：MyBatis不会对应用程序或数据库的现有设计强加任何影响。SQL语句写在XML文件中，与程序代码完全分离，降低了耦合度，便于统一管理和优化。
3. **动态SQL支持**：MyBatis提供了XML标签，支持编写动态SQL语句，使SQL语句更加灵活和可复用。
4. **ORM映射**：MyBatis支持对象与数据库的ORM字段关系映射，通过提供映射标签，可以方便地维护对象关系。
5. **DAO层支持**：MyBatis通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统设计更清晰，也更易维护和进行单元测试。

三、功能架构

MyBatis的功能架构主要包括以下几个部分：

* **API接口层**：提供给外部使用的接口API，开发者通过这些本地API来操作数据库。接口层接收到调用请求便会调用数据处理层来完成具体的数据处理。
* **数据处理层**：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。主要目的是根据调用的请求完成一次数据库操作。
* **基础支撑层**：负责最基础的功能支撑（连接管理、事务管理、配置加载和缓存处理）等，这些都是共用的，将其抽取出来作为最基础的组件。

四、使用方式

MyBatis使用简单的XML或注解用于配置和原始映射，将接口和Java的POJOs（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。MyBatis Generator是一个工具，可以自动生成Dao层、Model层和Mapper层，以简化开发过程。

综上所述，MyBatis是一个功能强大、灵活易用的持久层框架，它封装了JDBC的底层实现细节，使开发者能够更专注于业务逻辑的实现。通过XML或注解的配置方式，MyBatis支持动态SQL、ORM映射和DAO层分离等功能，为Java应用程序提供了高效的数据访问解决方案。


> Prompt for 文心一言3.5: 一般而言我们还有必要熟练掌握JDBC代码吗

在当今的软件开发中，虽然JDBC（Java Database Connectivity）是Java访问数据库的基础API，但**对于大多数应用开发者而言，熟练掌握JDBC代码可能不再是必要的**。这主要是因为存在许多高级框架和库，如MyBatis、Hibernate等，它们封装了JDBC的底层细节，提供了更高级别的抽象和更多的功能。

不过，了解JDBC的工作原理和基本概念仍然是非常重要的。这是因为：

1. **理解底层机制**：即使使用高级框架，理解JDBC如何与数据库进行交互仍然是有价值的。这有助于你更好地理解数据访问层的工作原理，以及如何解决可能出现的问题。

2. **调试和优化**：如果你遇到了性能问题或与数据库相关的错误，并且需要深入了解问题根源，那么熟悉JDBC将是非常有帮助的。你可能需要查看底层的SQL语句、连接池配置或事务管理。

3. **跨框架和库的能力**：不同的项目和团队可能使用不同的数据库访问技术。即使你主要使用MyBatis或Hibernate，但在某些情况下，你可能需要处理使用JDBC的遗留代码或与其他使用JDBC的团队进行协作。

4. **学习和成长**：对JDBC的理解可以帮助你更深入地学习其他数据库访问技术。了解这些技术的相似之处和差异将使你成为一个更全面、更灵活的开发者。

5. **自定义需求**：在某些特殊情况下，高级框架可能无法满足你的需求，这时你可能需要直接使用JDBC来编写自定义的数据库访问代码。

因此，虽然熟练掌握JDBC代码可能不再是必要的，但了解它的工作原理和基本概念仍然是非常重要的。这将使你成为一个更全面、更灵活的开发者，能够更好地应对各种数据库访问需求。


### Maven项目管理和构建工具

> Prompt for ChatGPT3.5: 请为我介绍一下Maven这个工具

Maven 是一个流行的项目管理和构建工具，用于 Java 项目的构建、依赖管理和项目信息管理。它可以自动化项目构建的过程，包括编译、测试、打包和部署等。下面是 Maven 的一些主要特点和功能：

1. **依赖管理：** Maven 管理项目依赖，通过 POM（Project Object Model）文件指定项目的依赖关系，Maven 会自动下载并构建项目所需的依赖包。

2. **标准化项目结构：** Maven 鼓励采用一致的项目结构，使得不同项目之间易于理解和管理。通常，Maven 项目遵循约定的目录结构，比如源代码放在 `src/main/java` 目录下，测试代码放在 `src/test/java` 目录下。

3. **插件生态系统：** Maven 提供了丰富的插件，可以扩展 Maven 的功能，比如编译源代码、运行测试、打包项目等。用户也可以编写自己的插件来满足特定需求。

4. **生命周期和阶段：** Maven 定义了一系列标准化的构建生命周期和阶段，比如 `clean`、`compile`、`test`、`package` 等。用户可以通过执行特定的生命周期阶段来执行相应的操作。

5. **中央仓库：** Maven 默认使用 Maven 中央仓库来管理依赖包，这是一个全球性的仓库，包含了大量的开源 Java 项目的构件。

6. **多模块支持：** Maven 支持多模块项目，可以将一个大型项目拆分成多个子模块，并通过父子模块之间的依赖管理来管理项目的复杂性。

7. **IDE 整合：** Maven 可以与各种流行的集成开发环境（IDE）集成，比如 Eclipse、IntelliJ IDEA 等，使得开发者可以在 IDE 中方便地使用 Maven 构建项目。

总的来说，Maven 提供了一个强大且灵活的项目管理和构建工具，使得 Java 开发者可以更高效地开发和管理项目。


> Prompt for ChatGPT3.5: Java还有哪些构建工具？对比一下他们之间的核心区别。

除了 Maven 外，还有一些其他流行的 Java 构建工具，其中两个主要的竞争对手是 Ant 和 Gradle。

1. **Ant:**
   - Ant 是一个基于 XML 的构建工具，它允许开发者通过编写 XML 构建脚本来定义项目的构建过程。Ant 侧重于灵活性和定制化，允许开发者完全控制构建过程，适用于较小规模、简单的项目。
   - Ant 没有像 Maven 那样提供标准化的项目结构和生命周期，开发者需要自行定义构建过程中的每个步骤。
   - Ant 插件相对较少，不如 Maven 和 Gradle 那样具有丰富的生态系统。

2. **Gradle:**
   - Gradle 结合了 Maven 和 Ant 的优点，它采用基于 Groovy 的领域特定语言（DSL）来定义构建脚本，提供了比 Ant 更简洁和易读的语法。
   - Gradle 支持声明式依赖管理，类似于 Maven，但更加灵活，允许动态版本、传递性依赖等。
   - Gradle 的性能通常比 Maven 更好，因为它使用了增量构建和并行构建等优化策略。
   - Gradle 提供了更强大的插件系统，可以方便地扩展其功能，支持自定义任务和插件开发。

比较核心区别：
- **语言和语法：** Maven 使用 XML 来定义项目配置和依赖管理，Ant 使用 XML 构建脚本，而 Gradle 使用 Groovy DSL（或 Kotlin DSL）来编写构建脚本。Gradle 的 DSL 更加灵活和易读。
- **生态系统和插件：** Maven 和 Gradle 拥有更丰富的生态系统和插件，可以满足更广泛的需求，而 Ant 插件相对较少。
- **性能和效率：** Gradle 在性能和效率方面通常优于 Maven，特别是对于大型项目或复杂的构建任务。Gradle 使用了一些优化策略，如增量构建和并行构建，从而提高了构建速度。
- **灵活性和定制化：** Ant 和 Gradle 更加灵活和定制化，允许开发者完全控制构建过程，而 Maven 更加约定优于配置，提供了标准化的项目结构和生命周期。


> Prompt for ChatGPT3.5: 进一步对比一下Gradle与Maven的优缺点，请使用表格的形式对比

下面是 Gradle 和 Maven 的优缺点对比：

| 特点         | Gradle                                     | Maven                                     |
|--------------|--------------------------------------------|------------------------------------------|
| 优点         | - 更灵活和可定制化的构建脚本语法（Groovy DSL）  | - 简单易用，约定优于配置                    |
|              | - 更丰富的插件生态系统                        | - 丰富的生态系统和插件                     |
|              | - 性能通常优于 Maven                           | - 大量文档和社区支持                       |
|              | - 支持增量构建和并行构建，提高构建效率         | - 自动依赖管理和传递性依赖解析               |
|              | - 支持多项目构建和多模块项目                   | - 标准化的项目结构和生命周期                 |
| 缺点         | - 初学成本较高，学习曲线陡峭                   | - XML 构建脚本相对冗长，可读性较差          |
|              | - 依赖管理相对复杂，可能需要更多配置           | - 插件版本兼容性问题可能导致构建失败         |
|              | - 对于简单项目，可能会显得过于繁重            | - 性能不如 Gradle，特别是对于大型项目         |
|              | - 在 IDE 集成方面不如 Maven 成熟                | - 自定义任务和插件开发相对复杂              |

总体来说，Gradle 更适合需要灵活性和定制化的项目，尤其是对于大型项目或具有复杂构建需求的项目。而 Maven 更适合于小型或中型项目，以及那些希望快速启动并采用约定优于配置的团队。



## 前端

### HTML、CSS与JS基础

> Prompt for 文心一言3.5: 前端开发需要哪些最基本的知识？

前端开发需要掌握的最基本知识可以归纳为以下几个方面：

一、基础语言与技能

1. **HTML（超文本标记语言）**：
   - 用于创建网页的结构和内容。
   - 需要理解HTML标签和属性的工作原理，能够编写结构清晰、语义化的HTML代码。
   - 学习HTML5的新特性和标签，以支持现代网页开发的需求。

2. **CSS（层叠样式表）**：
   - 用于定义网页的样式和布局。
   - 需要掌握CSS选择器、盒模型、布局方式（如Flexbox和Grid）等基本概念。
   - 学习CSS3的新增特性，如动画、过渡和转换等，以丰富网页的视觉效果。

3. **JavaScript**：
   - 现代前端开发中最重要的语言之一。
   - 熟练掌握JavaScript的基础语法、数据类型、变量、函数等概念。
   - 了解DOM操作、事件处理、异步编程等进阶知识。
   - 学习ES6+的新特性，如箭头函数、模块导入导出、Promise等。

二、响应式设计

- 理解响应式设计的基本原理和重要性。
- 掌握媒体查询、弹性布局（Flexbox）、流式布局等技术，实现不同设备和屏幕尺寸下的良好展示效果。

三、前端框架和库

- 熟悉主流的前端框架和库，如React、Vue、Angular等。
- 理解这些框架和库的基本概念和工作原理，如组件化开发、状态管理、虚拟DOM等。
- 根据项目需求选择合适的框架或库进行开发。

四、版本控制

- 熟练使用版本控制工具，如Git。
- 理解Git的基本原理和使用命令，能够进行代码合并、解决冲突等操作。
- 掌握分支管理、标签管理等高级用法，以更好地协作开发和维护代码。

五、其他技能

1. **图片处理**：掌握基本的图片处理技术，如裁剪、缩放、调整格式等。PS（Photoshop）是常用的图片处理工具之一。
2. **SEO（搜索引擎优化）**：了解SEO的基本概念和原理，优化HTML结构和标签的使用，提高网页在搜索引擎中的排名。
3. **性能优化**：了解前端性能优化的方法和技术，如减少HTTP请求、压缩文件、使用CDN等，以提高网页的加载速度和用户体验。
4. **跨浏览器兼容性**：了解不同浏览器之间的兼容性问题，编写兼容多种浏览器的代码。

总结来说，前端开发需要掌握HTML、CSS、JavaScript等基础语言与技能，以及响应式设计、前端框架和库、版本控制等其他必要技能。通过不断学习和实践，可以不断提高自己的前端开发能力。


### React框架

> Prompt for ChatGPT3.5: 介绍一下React框架，它帮开发者解决什么问题，有它没它有什么区别

React是一个由Facebook开发的JavaScript库，用于构建用户界面。它主要用于构建单页面应用程序（SPA），其中页面内容在不重新加载整个页面的情况下进行动态更新。React的主要特点是其组件化和虚拟DOM（Virtual DOM）的概念。

1. **组件化**：React允许开发者将用户界面分解为独立可重用的组件。每个组件都有自己的状态（state）和属性（props），并且可以根据这些属性和状态来动态地渲染UI。这种组件化的方式使得代码更加模块化、可维护性更高，并且可以更容易地共享和重用代码。

2. **虚拟DOM**：React使用虚拟DOM来提高性能。虚拟DOM是一个内存中的表示，它对应着真实DOM的层次结构。当组件的状态发生变化时，React首先会在虚拟DOM中进行更新，然后通过比较虚拟DOM和真实DOM的差异，只更新必要的部分，最后才将变化的内容更新到真实DOM中。这种方式避免了直接操作DOM所带来的性能损耗，使得页面更新更加高效。

3. **单向数据流**：React采用了单向数据流的模式，即数据只能从父组件流向子组件，子组件不能直接修改父组件的数据。这种模式使得数据流更加清晰可控，降低了组件之间的耦合度。

React能够帮助开发者解决以下问题：

- **组件化开发**：通过将用户界面拆分为多个独立的组件，使得代码更易于维护和扩展。
- **提高性能**：通过虚拟DOM和高效的更新算法，减少了对真实DOM的频繁操作，从而提高了页面渲染的性能。
- **更好的可重用性**：组件化的方式使得开发者可以更轻松地重用和共享代码，提高了开发效率。
- **单向数据流**：采用单向数据流模式可以降低代码复杂度，减少了出错的可能性。

没有使用React，开发者可能需要手动操作DOM来更新页面内容，这样会导致代码变得复杂且难以维护，同时性能也会受到影响。React的出现极大地简化了前端开发的流程，提高了开发效率和页面性能。


### Next.js开发框架

> Prompt for 文心一言3.5: 类似Next.js这种基于React的前端开发框架有哪些？用表格对比一下优缺点

类似Next.js这种基于React的前端开发框架有多个，以下是一些常见的框架及其优缺点对比表格：

| 框架 | 优点 | 缺点 |
| --- | --- | --- |
| Next.js | 1. 优秀的服务器端渲染（SSR）和静态网站生成（SSG）支持，提高性能和SEO。 | 1. 对于初学者来说，配置和部署可能稍显复杂。 |
| | 2. 内置路由、代码拆分、热模块替换等高级功能，简化开发流程。 | 2. 依赖Node.js环境，可能不适合所有项目需求。 |
| | 3. 丰富的插件生态系统和社区支持。 | 3. 相对于其他轻量级框架，可能引入更多依赖和包大小。 |
| Gatsby | 1. 专注于静态网站生成，性能出色。 | 1. 主要用于博客和文档类网站，可能不适合复杂应用。 |
| | 2. 丰富的GraphQL数据源和插件生态系统。 | 2. 学习曲线可能较陡峭，需要熟悉GraphQL。 |
| | 3. 内置的样式和布局组件。 | 3. 可能需要额外的配置和优化以实现高性能。 |
| Create React App | 1. 简单的项目设置和构建流程，适合初学者。 | 1. 相对于其他框架，功能可能较为基础。 |
| | 2. 内置Webpack和Babel等构建工具，无需额外配置。 | 2. 定制性可能较低，不适合复杂需求。 |
| | 3. 官方文档和社区支持丰富。 | 3. 对于需要高级功能的项目，可能需要额外引入其他库或工具。 |
| Razzle | 1. 同时支持服务器端渲染和客户端渲染。 | 1. 相对于其他框架，知名度可能较低，社区支持有限。 |
| | 2. 内置Webpack和Express等构建和服务器工具。 | 2. 可能需要额外的配置和优化以实现高性能。 |
| | 3. 易于与Redux、MobX等状态管理库集成。 | 3. 学习曲线可能较陡峭，需要熟悉多个工具和库。 |

请注意，以上表格仅列出了每个框架的一些主要优点和缺点，并不代表所有方面。在选择基于React的前端开发框架时，请根据您的项目需求、团队技能和偏好进行综合考虑。同时，也可以查阅官方文档、社区讨论和教程等资源，以获取更详细的信息和比较。


### Axios网络请求

> Prompt for ChatGPT3.5: 前后端的网络请求如何处理，有什么成熟工具可以用？对比一下优缺点

前后端的网络请求处理是在前端发起HTTP请求，后端接收并处理这些请求，然后返回相应的数据给前端。在现代的Web开发中，有许多成熟的工具和技术可用于处理网络请求。

前端处理网络请求：

1. **原生XHR（XMLHttpRequest）**：
   - **优点**：
     - 原生支持浏览器的标准API，可跨浏览器使用。
     - 灵活性较高，可实现各种自定义需求。
   - **缺点**：
     - 使用起来繁琐，代码冗长。
     - 不支持Promise，需要使用回调函数处理异步操作。
     - 对复杂的数据结构处理能力有限。

2. **Fetch API**：
   - **优点**：
     - 提供了更简洁的API，支持Promise，使得异步操作更易于管理。
     - 原生支持流式请求和响应。
   - **缺点**：
     - 兼容性不如XHR，需要进行polyfill处理。
     - 在处理请求超时和取消等方面不够灵活。

3. **Axios**：
   - **优点**：
     - 基于Promise，易于处理异步操作。
     - 提供了丰富的配置选项和拦截器，增强了可扩展性。
     - 支持在Node.js环境中使用。
   - **缺点**：
     - 需要额外的库依赖，增加了项目的体积。
     - 对于简单的请求，可能会显得过于臃肿。

在选择工具时，需要根据项目需求、团队技术栈和个人偏好进行权衡。Axios在前端网络请求中是一个广泛使用且成熟的选择，而Express.js是后端处理网络请求的一个流行框架。


## 通过Github Action持续集成

> Prompt for 文心一言3.5: 介绍一下使用Github Action构建个人CICD工作流

当使用GitHub Actions来构建个人的CI/CD（持续集成/持续部署）工作流时，你可以自动化你的软件开发流程，从代码提交到测试、构建、部署等各个环节。GitHub Actions 允许你在 GitHub 仓库中直接定义工作流，这使得集成到你的开发过程中变得非常简单。

以下是使用GitHub Actions构建个人CI/CD工作流的基本步骤：

1. 创建工作流文件

在 GitHub 仓库的 `.github/workflows` 目录下创建一个 YAML 文件来定义你的工作流。例如，你可以创建一个名为 `ci.yml` 的文件。

2. 配置工作流

在 YAML 文件中，你可以定义工作流的触发器、所需的环境、要执行的步骤等。

一个基本的 CI 工作流可能如下所示：


```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js environment
        uses: actions/setup-node@v2
        with:
          node-version: 14
      - run: npm ci
      - run: npm test
```
在这个例子中：

* 工作流被命名为 `CI`。
* 它会在 `main` 分支上的 push 操作或 pull request 被触发时运行。
* 它有一个名为 `build` 的 job，该 job 在 `ubuntu-latest` 环境的虚拟机上运行。
* job 中有多个步骤，包括检出代码、设置 Node.js 环境、安装依赖和运行测试。

3. 自定义工作流

你可以根据你的项目需求来定制工作流。例如，你可能需要添加构建步骤、代码格式检查、部署到服务器等。

4. 使用 Marketplace 中的动作

GitHub Marketplace 提供了大量的预构建动作，你可以在你的工作流中直接使用它们。这些动作可以覆盖从构建到部署的各个方面，如 Docker 构建、Kubernetes 部署、AWS 部署等。

5. 手动触发工作流

除了自动触发外，你还可以手动触发工作流。这在你需要执行某些特定的任务（如部署到生产环境）时非常有用。

6. 查看工作流日志和结果

在 GitHub 仓库的 "Actions" 标签页中，你可以查看工作流的日志和结果。这可以帮助你调试问题并跟踪工作流的进度。

7. 安全性考虑

当使用 GitHub Actions 时，请确保你遵循最佳的安全实践。例如，不要在工作流中存储敏感信息（如密码、密钥等），而是使用环境变量或密钥管理工具来安全地存储这些信息。

总之，GitHub Actions 是一个强大的工具，可以帮助你自动化你的软件开发流程。通过定义适合你的项目的工作流，你可以提高开发效率、减少错误并更快地交付高质量的软件。